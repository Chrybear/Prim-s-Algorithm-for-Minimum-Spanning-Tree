#   Author: Charles Ryan Barrett
#   Purpose: Create a minimum spanning tree
#   Input: A square 2-D array of weights taken from a graph of vertices.
#   Output: Path for a minimum spanning tree based on given weights
#   For: CSC 320 bonus points

import math

def prim(w):
    f = []  # list of edges
    nearest = [1]*(len(w)-1)
    vnear = 0

    # Fill up distance array
    distance = w[0][1:]

    for i in range(1, len(w)):
        miny = math.inf
        print('Distance = ',distance)
        print('Nearest = ',nearest)
        print()
        for j in range(0, len(distance)):
            if 0 <= distance[j] < miny:
                miny = distance[j]
                vnear = j

        edge = [nearest[vnear] + 1, vnear + 1]  # Adding 1 because most vertices don't start at 1. For display only
        f.append(edge)
        distance[vnear] = -1

        for j in range(0, len(distance)):
            if w[j][vnear] < distance[j]:
                distance[j] = w[j][vnear]
                nearest[j] = vnear
    print(distance)
    print(nearest)
    return f


def main():
    print('Yer doing good, lad!')
    ifn = math.inf

    w = [[0, 1, 3, ifn, ifn],
         [1, 0, 3, 6, ifn],
         [3, 3, 0, 4, 2],
         [ifn, 6, 4, 0, 5],
         [ifn, ifn, 2, 5, 0]
         ]
    print(prim(w))


if __name__ == '__main__':
    main()
